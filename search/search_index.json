{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Git Queue Documentation A GitHub Action to handle job queues stored in Git . Welcome to the Git Queue documentation for the Git Queue - GitHub Action . Git Queue is a job queue with concurrency optimistic lock mechanism to guarantee job execution order (by updating the job state), implemented with a event sourcing approach, using empty git commits as the event store. Currently with one pending-to-process job limit. This is how git log looks when you use the queue: The queue has the following characteristics: It only allows processing one pending job at the same time. Jobs are done by GitHub workflows intended to create git commits and merge them into target branches. It provides an optimistic locking mechanism to guarantee that commits are merged in a mutual exclusion way, avoiding duplicate commits. When the queue accepts more than one active job (not finished) it will also guarantee the execution order. And features: More than one pending job. Log job execution: start-job , finish-job . Custom payload for queue commands. Check the Roadmap for upcoming features. Use case One comment use case is updating a submodule in a project when the submodule repository is updated. You have two Git repositories: R1 and R2 . R1 is a submodule of R2 . When a new commit is added to the main branch in R1 you want to update the submodule in R2 . You have a scheduled workflow W in R2 to import the latest changes from R1 . T1 . Add a new file to the library ( 1.txt ) T2 . We run W1 to update the library, however, for some reason, this process takes more than 10 minutes. T3 . We modify file 1.txt in the library. T4 . (T2+10\") We run a second workflow W2 to update the library. T5 . The workflow W2 finishes and creates a commit with the second version of file 1.txt . T6 . The workflow W1 finishes and overwrites the first version of file 1. txt`. Credits Original idea by Cameron Garnham . The gpg.ts and openpgp.ts files were originally copied from this GitHub Action repository . License MIT. See LICENSE for more details. Projects using Git Queue Chinese Ideographs Website","title":"Home"},{"location":"#git-queue-documentation","text":"A GitHub Action to handle job queues stored in Git . Welcome to the Git Queue documentation for the Git Queue - GitHub Action . Git Queue is a job queue with concurrency optimistic lock mechanism to guarantee job execution order (by updating the job state), implemented with a event sourcing approach, using empty git commits as the event store. Currently with one pending-to-process job limit. This is how git log looks when you use the queue: The queue has the following characteristics: It only allows processing one pending job at the same time. Jobs are done by GitHub workflows intended to create git commits and merge them into target branches. It provides an optimistic locking mechanism to guarantee that commits are merged in a mutual exclusion way, avoiding duplicate commits. When the queue accepts more than one active job (not finished) it will also guarantee the execution order. And features: More than one pending job. Log job execution: start-job , finish-job . Custom payload for queue commands. Check the Roadmap for upcoming features.","title":"Git Queue Documentation"},{"location":"#use-case","text":"One comment use case is updating a submodule in a project when the submodule repository is updated. You have two Git repositories: R1 and R2 . R1 is a submodule of R2 . When a new commit is added to the main branch in R1 you want to update the submodule in R2 . You have a scheduled workflow W in R2 to import the latest changes from R1 . T1 . Add a new file to the library ( 1.txt ) T2 . We run W1 to update the library, however, for some reason, this process takes more than 10 minutes. T3 . We modify file 1.txt in the library. T4 . (T2+10\") We run a second workflow W2 to update the library. T5 . The workflow W2 finishes and creates a commit with the second version of file 1.txt . T6 . The workflow W1 finishes and overwrites the first version of file 1. txt`.","title":"Use case"},{"location":"#credits","text":"Original idea by Cameron Garnham . The gpg.ts and openpgp.ts files were originally copied from this GitHub Action repository .","title":"Credits"},{"location":"#license","text":"MIT. See LICENSE for more details.","title":"License"},{"location":"#projects-using-git-queue","text":"Chinese Ideographs Website","title":"Projects using Git Queue"},{"location":"development/","text":"Development You can read our CONTRIBUTING and CODE_OF_CONDUCT guides before star contributing. Requirements Node >= 16.13.2. The action has only been tested with Linux. Make sure you do not alter the queue commits with destructive commands like git --amend or git rebase . In general, command that rewrite or reorganize commits could affect the queue integrity. Install Install with yarn install . Testing Run all tests with yarn test . Run only unit tests with yarn test-unit . Run only unit tests with yarn test-e2e . Linting Run TypeScript linter yarn format && yarn lint . Run MegaLinter locally: mega-linter-runner -e 'ENABLE=MARKDOWN' You can use the -e option to select the linters you want to execute. Build the typescript and package it for distribution yarn build && yarn package . Run locally You can run the app locally: yarn run build && \\ INPUT_QUEUE_NAME=\"queue-name\" \\ INPUT_ACTION=\"next-job\" \\ node dist/index.js Where inputs are environment variables with the prefix INPUT_ and the input name in uppercase. You can run workflows locally with the act app. Commit conventions General conventions : We follow Conventional Commits Specification . When we integrate a new dependency or upgrade dependencies, each indivisible dependency change (update, remove, add) should have its own commit including: Updated package.json file. Updated yarn.lock . Regenerated dist directory. Updated documentation, if needed. Minimal changes to the code to accommodate the change in the dependencies. We require signed commits. Conventions related to pull requests : We use merge commits. Make sure commits keep their signatures. Conventions related to releases : Every commit should build the application with yarn build && yarn package because every single commit should be executable on a third-party workflow and the action has to be already built in the dist folder. In some cases, commits are generated automatically, for example by the dependabot or MegaLinter (if enabled). Those bots do not build and package the action, so whoever is responsible for merging those commits should change them to include the built app. That could be very tedious work so very often could be more convenient just to re-create manually those changes including the built app (for example when you are updating some node packages at the same time). The same logic applies to signed commits ( dependabot creates signed commits but MegaLinter does not), that's one of the reasons why auto-fix is not enabled for MegaLinter . For some commits, the dist folder might not be affected, which means if you run yarn build && yarn package again the commit content for the dist folder is not going to change. In such cases, you could merge dependabot commits directly from the GitHub interface. That happens when dependabot upgrades an action in a workflow. In general, changes in the .github folder do not affect the dist folder. Update node dependencies Dependencies updates should be in an independent branch, as any other code modification. We are reusing always the same issue and the same branch name( issue-183-update-node-dependencies ) for dependencies update. That way we have a dependency update history (issue) and a consistent updates branch that can be used for automation. If a dependency breaks the code (i.e, does not compile or the tests do not pass), it should be solved in a separate, specific issue. Given everything, the process of dependencies updates would be as follows: General update (roughly once a week): Create the branch (using always the same name) Execute yarn upgrade --major Execute tests If tests do not pass or do not compile, exclude update that causes it to solve it a separate issue Create PR as usual Merge+rebase as usual Write a comment on the update issue to list all the dependabot PRs applied in this update iteration Affected dependabot PRs should be closed after applied, or close them manually If a security alert is warned by dependabot (critical security vulnerability) proceed immediately with the same workflow, but only with the update that patches it using a specific issue. For not critical updates we update them roughly once a week. NOTE: be aware of merging dependabot PRs directly using the GitHub interface. In some cases might produce unverified commits . When GitHub cannot sign the rebased commits. How to create pull requests In order to contribute you should follow the next steps: Make sure there is an issue for your contribution. You can pick up one of the already-define issues or create a new issue describing what you want to implement, fix, ... Create a fork and a new branch following the branch name convention: issue-XXX-short-description-or-issue-title-with-kebab-case-format Make your changes and commit them using Conventional Commits format. Make sure you sign your commits. It is very important that all commits have a distribution package of the application. That means you should run always: yarn install && yarn build && yarn package before committing. That sometimes changes the content of the dist folder. Those changes should be included in the commit. That command is going to build the app but it's also going to test it and fix the TypeScript linting. The target branch for your pull request should be develop . Keep you branch rebased with develop branch. Recommendations: If you do not run MegaLinter locally, we recommend you to push each new commit to a draft pull request in order to be sure all checks pass for every commit. It could be quiet annoying try to fix all commits at the end, when you have finished the issue implementation. If you have a MegaLinter error you can check the workflow log . At the beginning of each linter processing you can see what MegaLinter is doing: [GitHub Status Reporter] Error posting Status for JAVASCRIPTwith standard: 403 GitHub API response: {\"message\":\"Resource not accessible by integration\",\"documentation_url\":\"https://docs.github.com/rest/reference/repos#create-a-commit-status\"} [Text Reporter] Generated TEXT report: /github/workspace/report/linters_logs/SUCCESS-JAVASCRIPT_STANDARD.log And where to get more info about the linter is using and its configuration. You can also download the reports as an artifact. Releases See commit conventions related to releases . More info about releases in this discussion . Publish to a distribution branch Actions are run from GitHub repos so we will check in the packed dist folder. Then run ncc and push the results: yarn package git add dist git commit -a -m \"prod dependencies\" git push origin releases/v1 Note: We recommend using the --license option for ncc, which will create a license file for all of the production node modules used in your project. Your action is now published! See the versioning documentation Action versioning After testing, you can create a v1 tag to reference the stable and latest V1 action. Documentation We are using MkDocs for this documentation site. Commands mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. mkdocs gh-deploy -v --force - Deploy to GitHub Pages . You might see this error when you try to execute those commands: $ mkdocs Command 'mkdocs' not found, but can be installed with: sudo apt install mkdocs You can install it with: pip install mkdocs Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Development"},{"location":"development/#development","text":"You can read our CONTRIBUTING and CODE_OF_CONDUCT guides before star contributing.","title":"Development"},{"location":"development/#requirements","text":"Node >= 16.13.2. The action has only been tested with Linux. Make sure you do not alter the queue commits with destructive commands like git --amend or git rebase . In general, command that rewrite or reorganize commits could affect the queue integrity.","title":"Requirements"},{"location":"development/#install","text":"Install with yarn install .","title":"Install"},{"location":"development/#testing","text":"Run all tests with yarn test . Run only unit tests with yarn test-unit . Run only unit tests with yarn test-e2e .","title":"Testing"},{"location":"development/#linting","text":"Run TypeScript linter yarn format && yarn lint . Run MegaLinter locally: mega-linter-runner -e 'ENABLE=MARKDOWN' You can use the -e option to select the linters you want to execute. Build the typescript and package it for distribution yarn build && yarn package .","title":"Linting"},{"location":"development/#run-locally","text":"You can run the app locally: yarn run build && \\ INPUT_QUEUE_NAME=\"queue-name\" \\ INPUT_ACTION=\"next-job\" \\ node dist/index.js Where inputs are environment variables with the prefix INPUT_ and the input name in uppercase. You can run workflows locally with the act app.","title":"Run locally"},{"location":"development/#commit-conventions","text":"General conventions : We follow Conventional Commits Specification . When we integrate a new dependency or upgrade dependencies, each indivisible dependency change (update, remove, add) should have its own commit including: Updated package.json file. Updated yarn.lock . Regenerated dist directory. Updated documentation, if needed. Minimal changes to the code to accommodate the change in the dependencies. We require signed commits. Conventions related to pull requests : We use merge commits. Make sure commits keep their signatures. Conventions related to releases : Every commit should build the application with yarn build && yarn package because every single commit should be executable on a third-party workflow and the action has to be already built in the dist folder. In some cases, commits are generated automatically, for example by the dependabot or MegaLinter (if enabled). Those bots do not build and package the action, so whoever is responsible for merging those commits should change them to include the built app. That could be very tedious work so very often could be more convenient just to re-create manually those changes including the built app (for example when you are updating some node packages at the same time). The same logic applies to signed commits ( dependabot creates signed commits but MegaLinter does not), that's one of the reasons why auto-fix is not enabled for MegaLinter . For some commits, the dist folder might not be affected, which means if you run yarn build && yarn package again the commit content for the dist folder is not going to change. In such cases, you could merge dependabot commits directly from the GitHub interface. That happens when dependabot upgrades an action in a workflow. In general, changes in the .github folder do not affect the dist folder.","title":"Commit conventions"},{"location":"development/#update-node-dependencies","text":"Dependencies updates should be in an independent branch, as any other code modification. We are reusing always the same issue and the same branch name( issue-183-update-node-dependencies ) for dependencies update. That way we have a dependency update history (issue) and a consistent updates branch that can be used for automation. If a dependency breaks the code (i.e, does not compile or the tests do not pass), it should be solved in a separate, specific issue. Given everything, the process of dependencies updates would be as follows: General update (roughly once a week): Create the branch (using always the same name) Execute yarn upgrade --major Execute tests If tests do not pass or do not compile, exclude update that causes it to solve it a separate issue Create PR as usual Merge+rebase as usual Write a comment on the update issue to list all the dependabot PRs applied in this update iteration Affected dependabot PRs should be closed after applied, or close them manually If a security alert is warned by dependabot (critical security vulnerability) proceed immediately with the same workflow, but only with the update that patches it using a specific issue. For not critical updates we update them roughly once a week. NOTE: be aware of merging dependabot PRs directly using the GitHub interface. In some cases might produce unverified commits . When GitHub cannot sign the rebased commits.","title":"Update node dependencies"},{"location":"development/#how-to-create-pull-requests","text":"In order to contribute you should follow the next steps: Make sure there is an issue for your contribution. You can pick up one of the already-define issues or create a new issue describing what you want to implement, fix, ... Create a fork and a new branch following the branch name convention: issue-XXX-short-description-or-issue-title-with-kebab-case-format Make your changes and commit them using Conventional Commits format. Make sure you sign your commits. It is very important that all commits have a distribution package of the application. That means you should run always: yarn install && yarn build && yarn package before committing. That sometimes changes the content of the dist folder. Those changes should be included in the commit. That command is going to build the app but it's also going to test it and fix the TypeScript linting. The target branch for your pull request should be develop . Keep you branch rebased with develop branch. Recommendations: If you do not run MegaLinter locally, we recommend you to push each new commit to a draft pull request in order to be sure all checks pass for every commit. It could be quiet annoying try to fix all commits at the end, when you have finished the issue implementation. If you have a MegaLinter error you can check the workflow log . At the beginning of each linter processing you can see what MegaLinter is doing: [GitHub Status Reporter] Error posting Status for JAVASCRIPTwith standard: 403 GitHub API response: {\"message\":\"Resource not accessible by integration\",\"documentation_url\":\"https://docs.github.com/rest/reference/repos#create-a-commit-status\"} [Text Reporter] Generated TEXT report: /github/workspace/report/linters_logs/SUCCESS-JAVASCRIPT_STANDARD.log And where to get more info about the linter is using and its configuration. You can also download the reports as an artifact.","title":"How to create pull requests"},{"location":"development/#releases","text":"See commit conventions related to releases . More info about releases in this discussion .","title":"Releases"},{"location":"development/#publish-to-a-distribution-branch","text":"Actions are run from GitHub repos so we will check in the packed dist folder. Then run ncc and push the results: yarn package git add dist git commit -a -m \"prod dependencies\" git push origin releases/v1 Note: We recommend using the --license option for ncc, which will create a license file for all of the production node modules used in your project. Your action is now published! See the versioning documentation","title":"Publish to a distribution branch"},{"location":"development/#action-versioning","text":"After testing, you can create a v1 tag to reference the stable and latest V1 action.","title":"Action versioning"},{"location":"development/#documentation","text":"We are using MkDocs for this documentation site.","title":"Documentation"},{"location":"development/#commands","text":"mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. mkdocs gh-deploy -v --force - Deploy to GitHub Pages . You might see this error when you try to execute those commands: $ mkdocs Command 'mkdocs' not found, but can be installed with: sudo apt install mkdocs You can install it with: pip install mkdocs","title":"Commands"},{"location":"development/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"glossary/","text":"Glossary Commit subject : The first line of the commit . Commit body : The rest of the commits message after the commit subject. Target branch : The branch to which the new commits generated by the job processing will be pushed.","title":"Glossary"},{"location":"glossary/#glossary","text":"Commit subject : The first line of the commit . Commit body : The rest of the commits message after the commit subject. Target branch : The branch to which the new commits generated by the job processing will be pushed.","title":"Glossary"},{"location":"use/","text":"Use You can use the action as an standard Github Action. - name: Create new job id: create-job uses: Nautilus-Cyberneering/git-queue@v1 with: git_repo_dir: ${{ runner.temp }}/temp_git_dir queue_name: 'library update - library-aaa' action: 'create-job' job_payload: '{\"field\": \"value\", \"state\": \"pending\"}' You can any any number of new jobs, but you can only process them in order. Inputs Name Type Command Query Description queue_name String all all Queue name. It cannot contain special characters or white spaces. action String all all Queue actions: create-job , next-job , start-job , finish-job . job_payload String all none Job payload. It can be any string. git_repo_dir String all all The git repository directory. The default value is the current working dir. git_commit_gpg_sign String all none The git commit --gpg-sign argument. git_commit_no_gpg_sign String all none The git commit --no-gpg-sign argument. Outputs The following outputs are available: Name Type Command Query Description job_created String create-job none Boolean, true if the job was successfully created. job_started String start-job none Boolean, true if the job was successfully started. job_finished String finish-job none Boolean, true if the job was successfully finished. job_commit String all none The commit hash of the newly created commits, when the action creates a new commit. job_payload String none next-job The job payload. Only for next-job action. Commands The Git Queue action has these commands. Create a new job: add a new job to the queue. Get the next job: get the next job pending to process. Start a job: create a new empty commit to mark the starting of a job. Finish a job: create a new empty commit to mark the finishing of a job. You can specify the command with the input: action . Create Job - name: Create new job id: create-job uses: Nautilus-Cyberneering/git-queue@v1 with: git_repo_dir: ${{ runner.temp }}/temp_git_dir queue_name: 'library update - library-aaa' action: 'create-job' job_payload: '{\"field\": \"value\", \"state\": \"pending\"}' Get next Job - name: Get next job id: get-next-job if: ${{ steps.create-job.outputs.job_created == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1 with: git_repo_dir: ${{ runner.temp }}/temp_git_dir queue_name: 'library update - library-aaa' action: 'next-job' Start Job - name: Mark job as started id: start-job if: ${{ steps.create-job.outputs.job_created == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1 with: git_repo_dir: ${{ runner.temp }}/temp_git_dir queue_name: 'library update - library-aaa' action: 'start-job' job_payload: '{\"field\": \"value\", \"state\": \"started\"}' Finish Job - name: Mark job as finished id: finish-job if: ${{ steps.create-job.outputs.job_created == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1 with: git_repo_dir: ${{ runner.temp }}/temp_git_dir queue_name: 'library update - library-aaa' action: 'finish-job' job_payload: '{\"field\": \"value\", \"state\": \"finished\"}' Environment variables If you need to pass environment variables to the git child process, you only need to set those variables by using the env section of the action: - name: Create job id: create-job uses: Nautilus-Cyberneering/git-queue@v1 with: queue_name: \"Library Update - library-aaa\" action: \"create-job\" job_payload: \"job_payload\" env: GNUPGHOME: '~/.gnupg' GIT_AUTHOR_NAME: 'A Committer' GIT_AUTHOR_EMAIL: 'committer@example.com' GIT_AUTHOR_DATE: '2005-04-07T22:13:13' GIT_COMMITTER_NAME: 'A Committer' GIT_COMMITTER_EMAIL: 'committer@example.com' GIT_COMMITTER_DATE: '2005-04-07T22:13:13' Design you workflows You can define your own workflows to create and consume jobs. You can also push directly to the target branch or create pull request. As an example, you could use the work-allocator and worker pattern. Work allocator: name: Work allocator on: push: branches: [main] schedule: - cron: \"0,10,20,30,40,50 * * * *\" workflow_dispatch: jobs: update: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v3 with: fetch-depth: 0 submodules: \"true\" - name: Get next job id: get-next-job uses: Nautilus-Cyberneering/git-queue@v1-beta with: queue_name: \"library-update\" action: \"next-job\" git_commit_no_gpg_sign: \"false\" - name: Create new job id: create-job if: ${{ steps.get-next-job.outputs.job_found == 'false' && steps.update-submodule.outputs.updated == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1-beta with: queue_name: \"library-update\" action: \"create-job\" job_payload: \"payload\" git_commit_no_gpg_sign: \"false\" - name: Show new git-queue commit if: ${{ steps.get-next-job.outputs.job_found == 'false' && steps.update-submodule.outputs.updated == 'true' && steps.create-job.outputs.job_created == 'true' }} run: | git show --show-signature ${{ steps.create-job.outputs.job_commit }} - name: Push new job to the queue id: push-job if: ${{ steps.get-next-job.outputs.job_found == 'false' && steps.update-submodule.outputs.updated == 'true' && steps.create-job.outputs.job_created == 'true' }} shell: bash run: | git push Worker: name: Worker on: push: branches: [main] schedule: - cron: \"0,10,20,30,40,50 * * * *\" workflow_dispatch: jobs: update: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v3 with: fetch-depth: 0 - name: Get next job id: get-next-job uses: Nautilus-Cyberneering/git-queue@v1-beta with: queue_name: \"library-update\" action: \"next-job\" git_commit_no_gpg_sign: \"false\" - name: Mark job as started id: start-job if: ${{ steps.get-next-job.outputs.job_found == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1-beta with: queue_name: \"library-update\" action: \"start-job\" job_payload: \"payload\" git_commit_no_gpg_sign: \"false\" # Begin mutual exclusion job # JOB PROCESSING HERE # End mutual exclusion job - name: Mark job as finished id: finish-job if: ${{ steps.start-job.outputs.job_started == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1-beta with: queue_name: \"library-update\" action: \"finish-job\" job_payload: \"payload\" git_commit_no_gpg_sign: \"false\" - name: Show new commits if: ${{ steps.get-next-job.outputs.job_found == 'true' }} run: | git log --pretty=\"fuller\" --show-signature -5 - name: Push id: push if: ${{ steps.get-next-job.outputs.job_found == 'true' }} shell: bash run: | git push","title":"Use"},{"location":"use/#use","text":"You can use the action as an standard Github Action. - name: Create new job id: create-job uses: Nautilus-Cyberneering/git-queue@v1 with: git_repo_dir: ${{ runner.temp }}/temp_git_dir queue_name: 'library update - library-aaa' action: 'create-job' job_payload: '{\"field\": \"value\", \"state\": \"pending\"}' You can any any number of new jobs, but you can only process them in order.","title":"Use"},{"location":"use/#inputs","text":"Name Type Command Query Description queue_name String all all Queue name. It cannot contain special characters or white spaces. action String all all Queue actions: create-job , next-job , start-job , finish-job . job_payload String all none Job payload. It can be any string. git_repo_dir String all all The git repository directory. The default value is the current working dir. git_commit_gpg_sign String all none The git commit --gpg-sign argument. git_commit_no_gpg_sign String all none The git commit --no-gpg-sign argument.","title":"Inputs"},{"location":"use/#outputs","text":"The following outputs are available: Name Type Command Query Description job_created String create-job none Boolean, true if the job was successfully created. job_started String start-job none Boolean, true if the job was successfully started. job_finished String finish-job none Boolean, true if the job was successfully finished. job_commit String all none The commit hash of the newly created commits, when the action creates a new commit. job_payload String none next-job The job payload. Only for next-job action.","title":"Outputs"},{"location":"use/#commands","text":"The Git Queue action has these commands. Create a new job: add a new job to the queue. Get the next job: get the next job pending to process. Start a job: create a new empty commit to mark the starting of a job. Finish a job: create a new empty commit to mark the finishing of a job. You can specify the command with the input: action .","title":"Commands"},{"location":"use/#create-job","text":"- name: Create new job id: create-job uses: Nautilus-Cyberneering/git-queue@v1 with: git_repo_dir: ${{ runner.temp }}/temp_git_dir queue_name: 'library update - library-aaa' action: 'create-job' job_payload: '{\"field\": \"value\", \"state\": \"pending\"}'","title":"Create Job"},{"location":"use/#get-next-job","text":"- name: Get next job id: get-next-job if: ${{ steps.create-job.outputs.job_created == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1 with: git_repo_dir: ${{ runner.temp }}/temp_git_dir queue_name: 'library update - library-aaa' action: 'next-job'","title":"Get next Job"},{"location":"use/#start-job","text":"- name: Mark job as started id: start-job if: ${{ steps.create-job.outputs.job_created == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1 with: git_repo_dir: ${{ runner.temp }}/temp_git_dir queue_name: 'library update - library-aaa' action: 'start-job' job_payload: '{\"field\": \"value\", \"state\": \"started\"}'","title":"Start Job"},{"location":"use/#finish-job","text":"- name: Mark job as finished id: finish-job if: ${{ steps.create-job.outputs.job_created == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1 with: git_repo_dir: ${{ runner.temp }}/temp_git_dir queue_name: 'library update - library-aaa' action: 'finish-job' job_payload: '{\"field\": \"value\", \"state\": \"finished\"}'","title":"Finish Job"},{"location":"use/#environment-variables","text":"If you need to pass environment variables to the git child process, you only need to set those variables by using the env section of the action: - name: Create job id: create-job uses: Nautilus-Cyberneering/git-queue@v1 with: queue_name: \"Library Update - library-aaa\" action: \"create-job\" job_payload: \"job_payload\" env: GNUPGHOME: '~/.gnupg' GIT_AUTHOR_NAME: 'A Committer' GIT_AUTHOR_EMAIL: 'committer@example.com' GIT_AUTHOR_DATE: '2005-04-07T22:13:13' GIT_COMMITTER_NAME: 'A Committer' GIT_COMMITTER_EMAIL: 'committer@example.com' GIT_COMMITTER_DATE: '2005-04-07T22:13:13'","title":"Environment variables"},{"location":"use/#design-you-workflows","text":"You can define your own workflows to create and consume jobs. You can also push directly to the target branch or create pull request. As an example, you could use the work-allocator and worker pattern. Work allocator: name: Work allocator on: push: branches: [main] schedule: - cron: \"0,10,20,30,40,50 * * * *\" workflow_dispatch: jobs: update: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v3 with: fetch-depth: 0 submodules: \"true\" - name: Get next job id: get-next-job uses: Nautilus-Cyberneering/git-queue@v1-beta with: queue_name: \"library-update\" action: \"next-job\" git_commit_no_gpg_sign: \"false\" - name: Create new job id: create-job if: ${{ steps.get-next-job.outputs.job_found == 'false' && steps.update-submodule.outputs.updated == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1-beta with: queue_name: \"library-update\" action: \"create-job\" job_payload: \"payload\" git_commit_no_gpg_sign: \"false\" - name: Show new git-queue commit if: ${{ steps.get-next-job.outputs.job_found == 'false' && steps.update-submodule.outputs.updated == 'true' && steps.create-job.outputs.job_created == 'true' }} run: | git show --show-signature ${{ steps.create-job.outputs.job_commit }} - name: Push new job to the queue id: push-job if: ${{ steps.get-next-job.outputs.job_found == 'false' && steps.update-submodule.outputs.updated == 'true' && steps.create-job.outputs.job_created == 'true' }} shell: bash run: | git push Worker: name: Worker on: push: branches: [main] schedule: - cron: \"0,10,20,30,40,50 * * * *\" workflow_dispatch: jobs: update: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v3 with: fetch-depth: 0 - name: Get next job id: get-next-job uses: Nautilus-Cyberneering/git-queue@v1-beta with: queue_name: \"library-update\" action: \"next-job\" git_commit_no_gpg_sign: \"false\" - name: Mark job as started id: start-job if: ${{ steps.get-next-job.outputs.job_found == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1-beta with: queue_name: \"library-update\" action: \"start-job\" job_payload: \"payload\" git_commit_no_gpg_sign: \"false\" # Begin mutual exclusion job # JOB PROCESSING HERE # End mutual exclusion job - name: Mark job as finished id: finish-job if: ${{ steps.start-job.outputs.job_started == 'true' }} uses: Nautilus-Cyberneering/git-queue@v1-beta with: queue_name: \"library-update\" action: \"finish-job\" job_payload: \"payload\" git_commit_no_gpg_sign: \"false\" - name: Show new commits if: ${{ steps.get-next-job.outputs.job_found == 'true' }} run: | git log --pretty=\"fuller\" --show-signature -5 - name: Push id: push if: ${{ steps.get-next-job.outputs.job_found == 'true' }} shell: bash run: | git push","title":"Design you workflows"}]}